# DEV GUIDE — Руководство для разработчиков

Короткое руководство для тех, кто вносит изменения в проект или добавляет новые derived views.

Архитектура пайплайна
- scan → parser → resolver → graph → signals → derived views → render
- Основные папки в `src/`:
  - `src/scanner` — файл/директория сканирование
  - `src/parser` — AST/парсинг файлов
  - `src/resolver` — разрешение импортов (tsconfig paths, package imports)
  - `src/graph` — построение dependency graph
  - `src/signals` — вычисление inline signals (risk / nav / hint)
  - `src/render` — визуализация и derived views (render_architecture_md.ts, render_tree.ts)
  - `src/pipeline` — orchestration (run_pipeline)

Где искать изменения
- New derived view: добавляйте логику в `src/render/` и покрывайте тестами в `test/`.
- Фикстуры: используйте `test/helpers/fixture_builder.ts` для построения deterministic RenderInput.

Как добавить новый derived view (шаблон)
1. Напишите рендерную функцию в `src/render/` или расширьте `render_architecture_md.ts`.
2. Используйте только `input.graph` и `input.signals` — не изменяйте pipeline в рендере.
3. Обеспечьте детерминизм: сортировки, POSIX путь, stableStringCompare/stableSort.
4. Добавьте unit/contract тест в `test/` с фикстурой и проверкой вывода.
5. Запустите `npm test`, `npx tsc --noEmit`, `npm run build`.

Тестовая политика
- Предпочитаемые тесты: контрактные (Vitest) покрывают вывод rendered markdown.
- Используйте `test/helpers/fixture_builder.ts` для создания входов и `fixture.buildRenderInput()` для render‑only тестов.
- Проверяйте детерминированность: два рендера одинаковы (могут сравнивать SHA или строку).

Quality gates
- `npm test` — все тесты должны пройти.
- `npx tsc --noEmit` — без ошибок типов.
- `npm run build` — успешно компилировать `dist/`.

Правила детерминизма
- Всегда сортируйте вслед за `stableStringCompare`/`stableSort`.
- Нормализуйте пути в POSIX формате (`/`), особенно перед сравнением.
- Не используйте системные временные метки или нестабильные операции в output.

Common pitfalls
- Windows пути: всегда заменяйте `\` на `/` при сравнении/рендере.
- Исключайте папку вывода (например ARCHITECTURE.md в корне) из скана, чтобы избежать self‑scan.
 - Если тесты зависят от signals, используйте fixture signals (fixture.signal) или run the full pipeline if you need compute_signals heuristics.

## Детерминизм

Почему это важно
- Рендер используется как источник фактов для людей и для кодовых агентов. Нестабильный вывод вызывает неверные рекомендации и увеличивает риск галлюцинаций.

Что может нарушить детерминизм
- Нестабильный порядок итерации (неотсортированные map/set/dir listings).
- Использование системного времени в рендерах или сигналах (mtime/ctime) без нормализации.
- Платформозависимые пути (`\\` на Windows) без нормализации в POSIX формат.
- Нестационарные API (например сетевые запросы) в процессе сканирования/парсинга.

Недопустимые факторы (не использовать в рендере/сигналах)
- системные временные метки (mtime/ctime)
- нестабильный порядок обхода файловой системы без явной сортировки
- платформо‑зависимые формы путей без нормализации
- любые сетевые/внешние вызовы, влияющие на результат анализа

Как проект предотвращает нарушения
- Явные stableSort / stableStringCompare в ключевых местах перед рендером.
- Нормализация путей в POSIX‑формат при сравнении/выводе.
- Запрет на включение нестабильных системных метрик в Markdown‑рендер (допускаются только для отладки и в отдельных вариантах `--full-signals`).
- Тесты проверяют детерминированность: два независимых рендера сравниваются по строковой равенстве/хешу.

Почему это критично для LLM
- LLM полагаются на предсказуемые факты; нестабильный контент служит источником противоречий и снижает доверие к автоматическим агентам.

## Контрактная телеметрия

Что считается контрактом
- Контрактами считаются явные input/output инварианты модуля: публичные API, функции/методы, структуры данных, предназначенные для потребления другими компонентами.

Детекция контрактов и ограничения
- Детекция контрактов в проекте основана на сигналах/якорях и текстовых/структурных паттернах в коде. Возможны false‑positive и false‑negative; эти сигналы служат для навигации и оценки риска, но НЕ являются формальной гарантией совместимости API.

Какие проверки НЕ делаются
- Проект не выполняет формальную верификацию контрактов (не сравнивает сигнатуры кода с внешней спецификацией).
- Не проводится динамическое тестирование контрактов во время анализа (без исполнения кода).

Какие сигналы являются "sticky" и какие — нет
- Sticky signals: агрегированные/инлайн‑сигналы, которые сохраняют состояние по входу/выходу при агрегации (например contract‑summary для entrypoints). Они могут влиять на budgeted summaries.
- Non‑sticky signals: временные подсказки и диагностические сигналы (например парс‑ошибки, временные warnings) — они отображаются, но не сохраняют «контрактное» состояние между рендерами.

Зачем это нужно кодовому агенту
- Агент принимает решения (например reorder или replace) на основе contract signals: input/out markers дают чёткую подсказку, где риск изменения API высок.

Рекомендации при изменениях
- При изменении логики сигнала убедитесь, что есть покрывающий контрактный тест и что детерминизм сохраняется.
