## Документация контрактов рендера — Project Architecture Mapper

Этот файл описывает публичные контракты, инварианты и рекомендации для кода, тестов и кодовых агентов,
которые работают с рендерером древовидного вывода проекта. Цель — предотвратить дублирование логики
и сохранить детерминированность вывода при изменениях.

Файл расположен: `docs/RENDER_CONTRACTS.md` (UTF-8 без BOM).

---

### Краткий контракт (2–4 строки)
- Вход: дерево узлов (структура Graph / Node) и последовательность булевых маркеров ancestryIsLast: boolean[]
  (каждый элемент указывает, является ли соответствующий предок последним дочерним элементом).
- Функция сборки префикса: `buildTreePrefix(ancestryIsLast: boolean[], nodeIsLast: boolean): string`.
- Выход: строка префикса для одной текстовой линии узла (содержит только пробелы и символы-ручки: `│`, `├`, `└`, `─`, ` `).
- Инвариант: одинаковый вход => одинаковый вывод (бит-в-бит), вывод UTF-8, не содержит лишних пробелов в конце.

---

### Публичные контракты и сигнатуры (суть)

- buildTreePrefix
  - Сигнатура: `buildTreePrefix(ancestryIsLast: boolean[], nodeIsLast: boolean): string`
  - Описание: создаёт канонический префикс для строки узла, комбинируя сегменты для каждого уровня предков
    и завершающий сегмент для текущего узла (включая варианты для last/branch).
  - Пример:
    - ancestryIsLast = [false, true], nodeIsLast = false
    - Результат: `"│   ├── "` (пример — точные символы зависят от текущей кодовой точки glyphs)
  - Ограничения:
    - pure function, без побочных эффектов
    - всегда возвращает один и тот же набор символов для данных входов

- renderTreeNode / renderNodeLine (внутренние, но контрактны для модификаций)
  - Принимают `ancestryIsLast` и `nodeIsLast` и должны вызывать только `buildTreePrefix` для создания префикса
  - Не должны напрямую конкатенировать ad-hoc сегменты "│   "/"    "/"├──" и т.п.

- Stub-строки (collapse / depth stubs)
  - Должны строиться через `buildTreePrefix` с корректным ancestry и `nodeIsLast=true`.
  - Текст stub-а (например, `...` или `(collapsed)`) — отдельно и легко тестируемое значение.

---

### Глифы и визуальные правила (каноника)

- Используемые символы (канонические):
  - вертикальный направляющий: `│`
  - ветвь: `├`
  - последний дочерний: `└`
  - горизонтальная линия для узла: `──` (две `─` для визуальной плотности)
  - отступ: 3 пробела после сегмента канала (`"│   "` или `"    "`)

- Правила применения:
  - Для каждого предка в ancestryIsLast: если предок последний — использовать `'    '` иначе `'│   '`.
  - Для текущего узла: если nodeIsLast — `└── ` иначе `├── `.
  - Не добавлять дополнительные spacer-хаки; если нужна backward-совместимость, добавьте тесты/golden-файл.

---

### Инварианты детерминизма

- Сортировки: любые списки дочерних элементов должны сортироваться в стабильном порядке перед рендером.
- Нельзя использовать `Object.keys(..)` без сортировки.
- Все кодовые точки и вычисления, влияющие на вывод, должны быть pure и без неупорядоченных итераций.
- Вывод всегда записывается как UTF-8 без BOM.

---

### Контракт для тестов (как писать регрессионные тесты)

- Добавляйте регрессионный тест при изменении любого визуального аспекта:
  1. Создайте входной фикстур (Graph/fixture) в `test/helpers` если нужно.
  2. Запустите pipeline/CLI, сгенерируйте артефакт в `tmp`.
  3. Добавьте `expect(output).toEqual(expectedString)` с точным строковым сравнением (happy path).
  4. Добавьте второй запуск генерации и в тесте опционально сравните SHA256 двух последовательных запусков для той же команды.

Пример запуска локально (PowerShell):

```powershell
# Сборка и тесты
npm run build; npm test

# Генерация артефакта (примеры)
node dist/cli/main.js . --depth=2 --out=out/manual/ARCH.depth2.md
node dist/cli/main.js . --full-signals --focus=src --out=out/manual/ARCH.full.focus.src.md
```

---

### Практические рекомендации для разработчиков и кодовых агентов

- Никогда не перестраивайте префикс вручную в коде — используйте `buildTreePrefix`.
- При изменении glyph‑наборов: 1) обновить `buildTreePrefix`, 2) обновить тесты (golden fixtures), 3) прогнать `npm test` и 2x генерацию артефактов и сравнить хеши.
- Для изменений, которые влияют на текстовой вывод, добавляйте одну строку в `CHANGELOG.md` и краткое описание в PR.
- Обеспечьте совместимость: если требуется backward-совместимость вывода, добавьте параметр/флаг `legacy-glyphs` и покрытие тестами.

Agent-specific checklist (если агент изменяет рендер):
  - Read-only: don't modify `src/parser`/`src/graph` behavior unless necessary.
  - Use repository tests as oracle; always run `npm test` before committing changes.
  - If generating artifacts for audit, produce two independent runs and compare SHA256 — add the hashes to the PR description.

---

### Edge cases и частые ловушки

- Пустой ancestry: вызов `buildTreePrefix([], true)` должен вернуть префикс для корня (обычно `""` + `└── ` или просто `""` в зависимости от фактической политики — проверьте реализацию).
- Глубокие деревья: ancestryIsLast длина = глубина узла. Не храните ancestry как мутируемое глобальное состояние — передавайте по стеку.
- Windows vs Unix line endings: репозиторий ожидает LF в артефактах; CI должен нормализовать EOL при генерации артефактов.

---

### PR checklist (короткий)

1. Обновлён `CHANGELOG.md` с одной строкой.
2. `npm run typecheck` проходит.
3. `npm run build` проходит.
4. `npm test` — зелёный.
5. Генерация артефактов: два запуска с одинаковыми входами дают одинаковые SHA256 — прикрепите хеши в PR.
6. Добавлены/обновлены регрессионные тесты для визуальных изменений.

---

Если нужно, могу:
- добавить ссылку на этот документ в `README.md` или `docs/AGENT_MANIFEST.md`,
- сгенерировать пример теста (Vitest) для `buildTreePrefix`,
- создать PR-патч с changelog и командой для создания ветки.

---

Примечание по тестам:
- В репозитории есть контрактный тест, который проверяет сохранение "архитектурной правды" при ограничении глубины: `test/contract_prd_truth_preservation_depth.test.ts`.
- Тест создаёт детерминированный фикстур, где подсетка скрывается флагом `--depth=2` и содержит структурный риск (cycle). Тест утверждает, что строка-стаб (collapsed stub) содержит индикатор скрытых сигналов `( !) X signal` с X >= 1.

Конец файла.
