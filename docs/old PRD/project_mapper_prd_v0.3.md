Ниже — **переписанный PRD v0.3 целиком** (единый документ), с усилением границ, модели сигналов, профилей архитектуры и diff-first. Я сохраняю твой стиль (практичный, инженерный), но делаю его **более “устойчивым к росту”**. Основа и формулировки взяты из v0.2 и реорганизованы. 

Название чата: **«PRD v0.3: Маппер архитектуры кодовой базы»**

---

# PRD v0.3: Project Architecture Mapper (Architecture Context Artifact)

**Статус:** Planning (v0.3)
**Цель документа:** Зафиксировать продуктовую сущность, границы ответственности, формат вывода и план развития.

---

## 0. Executive Summary

**Project Architecture Mapper** генерирует **Architecture Context Artifact** — компактную текстовую карту проекта (`ARCHITECTURE.md`), оптимизированную для **планирования** рефакторинга человеком и AI-агентами. Он показывает структуру, ключевые зависимости и «точки риска» с помощью сигналов (cycles, layer breaches, hotspots и т.д.), не пытаясь быть «истиной в последней инстанции».

Главная ценность: **дать LLM “карту местности” до чтения файлов**, чтобы снизить токены, ускорить понимание проекта и повысить качество плана рефакторинга. 

---

## 1. Problem Statement

### Для кого

* Разработчики, использующие AI-агентов (Roo Code, Cursor, Claude Code и т.д.) для рефакторинга и навигации по легаси.
* Tech Leads / Архитекторы для быстрой диагностики структуры и регрессий в PR.

### Боль

1. **LLM не видит целостную картину проекта**, пока не прочитает слишком много файлов → дорого и медленно по токенам.
2. Инструменты типа `madge`, `dependency-cruiser` чаще дают:

   * огромный JSON
   * граф-картинки, которые LLM фактически не может «прочитать» как контекст для планирования
3. Разработчику трудно быстро понять:

   * где циклы
   * где нарушения изоляции
   * где “god modules”
   * где настоящие hotspots по изменениям
4. Текущий workaround: **ручной “архитектурный ввод” в промпте**, который неполный и невоспроизводимый. 

---

## 2. What This Tool Is / Is Not (границы ответственности)

### This tool IS

* **Генератор контекстной карты** (Architecture Context Artifact), пригодной для LLM и человека.
* **Навигация + приоритизация**, чтобы планировать чтение файлов и рефакторинг.
* **Эвристический анализ структуры и импортов** (с быстрыми правилами и понятными ограничениями).

### This tool IS NOT

* ❌ Линтер / “enforcement” инструмент архитектурных правил
* ❌ CI-gate по умолчанию (может использоваться в review, но не как строгий блокер)
* ❌ Автоматический рефакторинг или “код-фикс”
* ❌ Семантический анализ бизнес-логики / data-flow анализ
* ❌ Инструмент для доказательства корректности архитектуры

**Философия:** лучше быстрая карта с полезными сигналами, чем “идеальный анализ”, который никто не запускает. 

---

## 3. Core Concept: Architecture Context Artifact

### Определение

**Architecture Context Artifact** — единый файл `ARCHITECTURE.md`, который:

* читается целиком (и человеком, и LLM),
* используется **до** чтения исходников,
* помогает **планировать** работу (что читать, с чего начинать, где риски),
* является **token-efficient** заменой “загрузить пол-репозитория в контекст”.

### Почему это важно именно для LLM

LLM лучше справляется, когда:

* сначала получает **карту**
* затем запрашивает **мало файлов**, но по правильному маршруту

---

## 4. Output: формат и требования к читаемости

### Основной формат вывода (Markdown + дерево)

* Дерево директорий/файлов
* У файла — краткая мета-информация + топ-N зависимостей (с сокращением)
* Сигналы помечаются компактно и единообразно

Пример (концептуально):

```markdown
# PROJECT CONTEXT MAP
Generated: 2026-01-20

Legend:
- (! ) Structural Risk
- (? ) Heuristic Hint
- (i ) Context Signal

/src
  /features/auth
    ├── index.ts              (! CYCLE -> ./model/store.ts -> ./index.ts)
    ├── ui/LoginForm.tsx      (120 loc) -> (./model, @/shared/ui)
    └── model/auth.store.ts   (450 loc) (? BIG) (? GOD-MODULE) (i HIGH-CHURN 50/m)
                              -> (@/shared/api, @/entities/user, ...)
```

### Принципы компактности

* **Только локальные импорты** (фокус на архитектуре проекта, не на node_modules)
* **Top-N импортов на файл** (например, 5) + `...` для хвоста
* Сигналы — короткие, но по возможности **конкретные**
* Для циклов — обязательно выводить **путь цикла**, а не просто флаг. 

---

## 5. Модель сигналов (Signals Model)

Сигналы — это **не ошибки**, а **навигационные подсказки**. Один и тот же сигнал может быть допустимым в контексте (например, большой файл в UI-kit).

### 5.1 Категории сигналов

#### A) Structural Risks `(!)`

С высокой вероятностью влияют на безопасность рефакторинга и качество модульности.

* `CYCLE` — циклические зависимости (с конкретным путём)
* `LAYER-BREACH` — нарушение изоляции слоёв (только в профиле, см. ниже)

#### B) Heuristic Hints `(? )`

Эвристики, помогающие найти кандидатов на улучшение, но без “вердикта”.

* `BIG` — файл больше порога N строк
* `GOD-MODULE` — слишком много входящих зависимостей (in-degree > M)
* `DEEP-PATH` — импорт через `../../../` глубже порога
* `BARREL-HELL` — “толстый index.ts” с большим числом экспортов (позже)

#### C) Context Signals `(i)`

Сигналы из контекста изменений (темпоральные).

* `HIGH-CHURN` — часто меняется
* `STALE` — давно не менялся
* `ORPHAN` — нет входящих импортов (осторожно: может быть entrypoint)

> Рекомендация для агентов: сначала устранять `(!)` прежде чем делать большие перетасовки.

---

## 6. Architecture Profiles (снятие “скрытой нормы”)

Чтобы инструмент был применим не только к FSD, вводим профили:

### 6.1 Default Profile (structure-agnostic)

Работает для любого репозитория:

* `BIG`, `CYCLE`, `GOD-MODULE`, `DEEP-PATH`, `ORPHAN`
* `HIGH-CHURN`, `STALE` (если доступен git)

### 6.2 FSD Profile (opt-in)

Включает правила слоёв и запреты:

* `LAYER-BREACH`
* `FEATURE-CROSS`

Важно: FSD — **не дефолтная норма**, а один из профилей.

### 6.3 Custom Profile (future)

Конфиг на правила слоёв/границ, чтобы команды могли описывать свою архитектуру.

---

## 7. How It Works (pipeline)

### Вход

* rootDir (`./src` по умолчанию)
* игнорирование (уважение `.gitignore` + стандартные exclude)
* пороги и лимиты (N строк, M in-degree, top-N импортов и т.д.)
* выбранный профиль (default/FSD/custom)

### Процесс

1. Сканирование файлов
2. Анализ файла:

   * LOC (строки)
   * импорты (локальные)
   * определение “модуля/слоя” по пути (если профиль требует)
3. Построение графа зависимостей
4. Детекция сигналов
5. Рендер в Markdown (дерево + краткие метки)

### Выход

* `ARCHITECTURE.md` в корне проекта (или по параметру). 

---

## 8. Parsing Strategy (Regex vs AST)

### MVP стратегия: Improved Regex (v0.2–0.3)

* многострочные импорты (best effort)
* re-exports `export { x } from ...`
* динамические импорты `import(...)` (best effort)

Плюсы: zero deps, быстро, просто.
Минусы: пропуски edge cases.

### Опционально: TypeScript Compiler API (v0.3+)

Если `typescript` уже есть в devDependencies — можно использовать его для точного парсинга, **без добавления новых зависимостей**.

Цель: повысить точность там, где это важно, но не ломать “быстро и без установки”. 

---

## 9. Diff-first use cases (как взрослая ценность)

Инструмент поддерживает сценарий **архитектурного diff**, где сравнивается не код, а структура/сигналы:

* “до/после” рефакторинга
* “main vs feature branch”
* review больших PR

Пример workflow:

* сгенерировать `ARCHITECTURE-before.md`
* сгенерировать `ARCHITECTURE-after.md`
* сравнить diff

Ценность: фиксируем **архитектурные регрессии** (например, появились новые циклы), даже если обычный diff по файлам “выглядит нормально”. 

---

## 10. AI Preamble (опциональный слой управления агентом)

### Идея

В начало `ARCHITECTURE.md` можно добавить **рекомендации для LLM**, как использовать карту.

### Ограничения

* Это **reference guidance**, а не контракт.
* Может быть полностью отключено.
* Может быть переписано пользователем под своего агента и процесс.

Пример:

```markdown
# AI INSTRUCTIONS (optional)
Use this file to plan before requesting sources.
Priority:
1) (! CYCLE) - break cycles before refactor
2) (i HIGH-CHURN + ? BIG) - start decomposition here
3) (! LAYER-BREACH) - requires inversion / boundary fix
Rules:
- Don't request more than 5 files without asking user
- Use map to choose next file
---
# PROJECT MAP
...
```



---

## 11. Focus Mode и масштабирование (для больших реп)

Проблема: 10k+ файлов → карта может стать слишком большой даже для человека/LLM.

Решение:

* `--depth`
* `--focus=path`
* collapsed sections по умолчанию (summary на уровне модулей)

Цель: уместить “стандартный” вывод в разумный объём (например, <300 строк для среднего проекта). 

---

## 12. Метрики успеха

### Количественные

* генерация <5 сек для ~2000 файлов (ориентир)
* размер вывода <300 строк для среднего проекта
* циклы выводятся с полным путём
* экономия токенов в сценариях “agent onboarding” кратно (ориентир 20–50x как в гипотезе)

### Качественные

* разработчик понимает структуру за ~2 минуты чтения карты
* агент строит план рефакторинга, запрашивая минимальное число файлов
* карта обнаруживает хотя бы одну значимую структурную проблему в большинстве легаси-проектов (как цель-гипотеза)

---

## 13. Roadmap (с фокусом и границами)

### v0.1 — базовая карта

* сканирование + LOC + импорты + `BIG` + Markdown

### v0.2 — критичные детекторы для безопасного рефакторинга

* `CYCLE` с путём
* уважение `.gitignore`
* улучшенный regex (multi-line, re-export)

### v0.3 — темпоральный контекст + режимы масштабирования

* `HIGH-CHURN`, `STALE` (git integration, graceful fallback)
* `--depth`, `--focus`
* (опционально) TS Compiler API auto-detect

### v0.4 — профильные проверки архитектуры

* `LAYER-BREACH` (profile-based)
* `FEATURE-CROSS` (profile-based)
* `GOD-MODULE`, `ORPHAN`, `DEEP-PATH`, `BARREL-HELL`

### v1.0 — production UX (без смены философии)

* CLI-параметры и конфиг
* pre-commit интеграция (опционально)
* diff-режим “first-class”
* watch mode (опционально)
* HTML-визуализация (опционально, только если не ломает основной сценарий)

---

## 14. Риски и ограничения

* Regex/Best-effort может пропускать импорты → опциональный AST/TS API
* Ложные срабатывания сигналов → настраиваемые пороги + категоризация сигналов (risk/hint/context)
* `ORPHAN` может быть entrypoint → осторожность в интерпретации
* Большие монолиты → focus/depth/summary
* FSD правила не применимы к не-FSD → профили, opt-in

---

## 15. Альтернативы (и почему не они)

* `madge`: JSON/PNG → не LLM-friendly для планирования
* `dependency-cruiser`: мощно, но тяжёлый конфиг и “вывод не для контекста”
* `tree`: структура без мета-сигналов
* ручной ввод: долго и невоспроизводимо



---

## 16. Non-Goals (жёстко)

* Не анализируем бизнес-смысл и потоки данных
* Не гарантируем полноту анализа импортов в regex-режиме
* Не делаем enforcement архитектуры
* Не заменяем линтеры и тесты
* Не строим идеальный граф — строим **читаемую карту**

---

Если хочешь, следующим шагом я сделаю **“diff ревизию”**: короткий список *что именно изменилось от v0.2 к v0.3* (в виде changelog), чтобы удобно было обсуждать в дискуссии и коммитить как PRD v0.3.
